{
  "session_id": "c71188d0-004a-4a2d-9ac8-672bf44b3e14",
  "transcript_path": "/home/sam/.claude/projects/-media-sam-1TB-UTXOracle/c71188d0-004a-4a2d-9ac8-672bf44b3e14.jsonl",
  "hook_event_name": "PreToolUse",
  "tool_name": "Write",
  "tool_input": {
    "file_path": "/media/sam/1TB/UTXOracle/live/backend/api.py",
    "content": "\"\"\"\nTask 04: FastAPI WebSocket Server\nAgent: data-streamer\n\nResponsibilities:\n- WebSocket endpoint for real-time data streaming\n- Client connection management\n- Broadcast price updates and histogram data\n- CORS configuration\n\"\"\"\n\nimport asyncio\nimport logging\nimport time\nfrom pathlib import Path\nfrom typing import List\n\nfrom fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.responses import HTMLResponse, JSONResponse\nfrom fastapi.staticfiles import StaticFiles\n\nfrom live.shared.models import (\n    MempoolState,\n    WebSocketMessage,\n    MempoolUpdateData,\n    TransactionPoint,\n    SystemStats,\n)\n\nlogger = logging.getLogger(\"live.api\")\n\n# FastAPI App Setup\napp = FastAPI(\n    title=\"UTXOracle Live API\",\n    description=\"Real-time Bitcoin price oracle from mempool analysis\",\n    version=\"1.0.0\",\n)\n\n# CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Static files\nfrontend_dir = Path(__file__).parent.parent / \"frontend\"\nif frontend_dir.exists():\n    app.mount(\"/static\", StaticFiles(directory=str(frontend_dir)), name=\"static\")\n\n\nclass DataStreamer:\n    \"\"\"Manages WebSocket client connections and broadcasts mempool updates\"\"\"\n\n    def __init__(self, max_updates_per_second: int = 10):\n        self.active_clients: List[WebSocket] = []\n        self.max_updates_per_second = max_updates_per_second\n        self.last_broadcast_time = 0.0\n        self.min_broadcast_interval = (\n            1.0 / max_updates_per_second if max_updates_per_second > 0 else 0.0\n        )\n\n    async def register_client(self, websocket: WebSocket) -> None:\n        \"\"\"Register a new WebSocket client (must already be accepted)\"\"\"\n        self.active_clients.append(websocket)\n        logger.info(f\"Client connected. Total clients: {len(self.active_clients)}\")\n\n    def unregister_client(self, websocket: WebSocket) -> None:\n        \"\"\"Unregister a disconnected WebSocket client\"\"\"\n        if websocket in self.active_clients:\n            self.active_clients.remove(websocket)\n            logger.info(\n                f\"Client disconnected. Total clients: {len(self.active_clients)}\"\n            )\n\n    async def broadcast(self, state: MempoolState) -> None:\n        \"\"\"Broadcast MempoolState to all connected clients\"\"\"\n        current_time = time.time()\n        if self.min_broadcast_interval > 0:\n            elapsed = current_time - self.last_broadcast_time\n            if elapsed < self.min_broadcast_interval:\n                return\n\n        if not self.active_clients:\n            return\n\n        message = self._create_websocket_message(state)\n        message_json = message.model_dump_json()\n\n        disconnected_clients = []\n        for client in self.active_clients:\n            try:\n                await client.send_text(message_json)\n            except Exception as e:\n                logger.warning(f\"Failed to send to client: {e}\")\n                disconnected_clients.append(client)\n\n        for client in disconnected_clients:\n            self.unregister_client(client)\n\n        self.last_broadcast_time = current_time\n\n    def _create_websocket_message(self, state: MempoolState) -> WebSocketMessage:\n        \"\"\"Convert MempoolState to WebSocketMessage (T068: includes transaction history)\"\"\"\n        transactions = []\n\n        # T068: Get transaction history from analyzer if available\n        if hasattr(self, \"analyzer\") and self.analyzer:\n            history = self.analyzer.get_transaction_history()\n            transactions = [\n                TransactionPoint(timestamp=ts, price=price) for ts, price in history\n            ]\n\n        stats = SystemStats(\n            total_received=state.total_received,\n            total_filtered=state.total_filtered,\n            active_in_window=state.active_tx_count,\n            uptime_seconds=state.uptime_seconds,\n        )\n\n        data = MempoolUpdateData(\n            price=state.price,\n            confidence=state.confidence,\n            transactions=transactions,\n            stats=stats,\n            timestamp=time.time(),\n        )\n\n        return WebSocketMessage(type=\"mempool_update\", data=data)\n\n    def get_client_count(self) -> int:\n        \"\"\"Get number of connected clients\"\"\"\n        return len(self.active_clients)\n\n\n# Global DataStreamer instance\nstreamer = DataStreamer(max_updates_per_second=10)\n\n\n@app.get(\"/\", response_class=HTMLResponse)\nasync def serve_index():\n    \"\"\"Serve frontend HTML\"\"\"\n    index_path = frontend_dir / \"index.html\"\n    if not index_path.exists():\n        return HTMLResponse(\n            content=\"<h1>UTXOracle Live</h1><p>Frontend not found</p>\",\n            status_code=404,\n        )\n    return HTMLResponse(content=index_path.read_text())\n\n\n@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Health check endpoint\"\"\"\n    return JSONResponse(\n        {\n            \"status\": \"ok\",\n            \"uptime\": time.time() - app.state.start_time,\n            \"clients\": streamer.get_client_count(),\n        }\n    )\n\n\n@app.websocket(\"/ws/mempool\")\nasync def websocket_endpoint(websocket: WebSocket):\n    \"\"\"WebSocket endpoint for real-time mempool updates\"\"\"\n    await websocket.accept()\n    await streamer.register_client(websocket)\n\n    try:\n        while True:\n            await websocket.receive_text()\n    except WebSocketDisconnect:\n        streamer.unregister_client(websocket)\n    except Exception as e:\n        logger.error(f\"WebSocket error: {e}\")\n        streamer.unregister_client(websocket)\n\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    \"\"\"Initialize app state and start pipeline orchestrator\"\"\"\n    from live.backend.orchestrator import get_orchestrator\n\n    app.state.start_time = time.time()\n    logger.info(\"UTXOracle Live API started\")\n\n    # Start pipeline orchestrator\n    logger.info(\"Initializing pipeline orchestrator...\")\n    orchestrator = get_orchestrator()\n    asyncio.create_task(orchestrator.start())\n    logger.info(\"Pipeline orchestrator task created\")\n\n\n@app.on_event(\"shutdown\")\nasync def shutdown_event():\n    \"\"\"Clean up and stop pipeline orchestrator\"\"\"\n    from live.backend.orchestrator import get_orchestrator\n\n    logger.info(\"UTXOracle Live API shutting down\")\n\n    # Stop pipeline orchestrator\n    logger.info(\"Stopping pipeline orchestrator...\")\n    orchestrator = get_orchestrator()\n    await orchestrator.stop()\n    logger.info(\"Pipeline orchestrator stopped\")\n\n\n__all__ = [\"app\", \"DataStreamer\", \"streamer\"]\n\n\n@app.get(\"/styles.css\")\nasync def serve_styles():\n    \"\"\"Serve CSS file\"\"\"\n    css_path = frontend_dir / \"styles.css\"\n    if not css_path.exists():\n        return HTMLResponse(content=\"/* CSS not found */\", status_code=404)\n    return HTMLResponse(content=css_path.read_text(), media_type=\"text/css\")\n\n\n@app.get(\"/mempool-viz.js\")\nasync def serve_js():\n    \"\"\"Serve JavaScript file\"\"\"\n    js_path = frontend_dir / \"mempool-viz.js\"\n    if not js_path.exists():\n        return HTMLResponse(content=\"// JS not found\", status_code=404)\n    return HTMLResponse(\n        content=js_path.read_text(), media_type=\"application/javascript\"\n    )\n"
  }
}