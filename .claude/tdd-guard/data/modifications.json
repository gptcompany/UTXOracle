{
  "session_id": "fdd4c6d3-dd93-4c4d-bd7f-be7daffb9be2",
  "transcript_path": "/home/sam/.claude/projects/-media-sam-1TB-UTXOracle/fdd4c6d3-dd93-4c4d-bd7f-be7daffb9be2.jsonl",
  "hook_event_name": "PreToolUse",
  "tool_name": "Edit",
  "tool_input": {
    "file_path": "/media/sam/1TB/UTXOracle/live/frontend/mempool-viz.js",
    "old_string": "/**\n * Task 05: Canvas 2D Visualization (MVP)\n * Agent: visualization-renderer\n *\n * Responsibilities:\n * - WebSocket client connection\n * - Real-time scatter plot rendering (Canvas 2D)\n * - Price histogram display\n * - Performance: <5k points (use WebGL for more)\n */\n\n// TODO: Implement Canvas 2D renderer (Task 05 - MVP)",
    "new_string": "/**\n * UTXOracle Live - Mempool Visualization\n *\n * WebSocket client for real-time price updates\n * Canvas 2D rendering (MVP: price display only)\n *\n * Tasks: T056-T059\n */\n\nclass MempoolVisualizer {\n    constructor(websocketUrl) {\n        this.ws = null;\n        this.url = websocketUrl;\n        this.reconnectDelay = 1000; // Start with 1 second\n        this.maxReconnectDelay = 30000; // Max 30 seconds\n        this.reconnectTimer = null;\n        this.isManualClose = false;\n\n        // DOM elements\n        this.priceEl = null;\n        this.confidenceEl = null;\n        this.statusEl = null;\n        this.statsEl = null;\n    }\n\n    /**\n     * Initialize and cache DOM elements\n     */\n    init() {\n        this.priceEl = document.getElementById('price');\n        this.confidenceEl = document.getElementById('confidence');\n        this.statusEl = document.getElementById('status');\n        this.statsEl = document.getElementById('stats');\n\n        if (!this.priceEl || !this.confidenceEl || !this.statusEl || !this.statsEl) {\n            console.error('Required DOM elements not found');\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * T056: Connect to WebSocket server\n     */\n    connect() {\n        // Clear any pending reconnection\n        if (this.reconnectTimer) {\n            clearTimeout(this.reconnectTimer);\n            this.reconnectTimer = null;\n        }\n\n        try {\n            this.ws = new WebSocket(this.url);\n\n            this.ws.onopen = () => {\n                console.log('WebSocket connected');\n                this.reconnectDelay = 1000; // Reset backoff\n                this.updateConnectionStatus(true);\n            };\n\n            this.ws.onmessage = (event) => {\n                try {\n                    const message = JSON.parse(event.data);\n                    this.handleUpdate(message);\n                } catch (error) {\n                    console.error('Failed to parse WebSocket message:', error);\n                }\n            };\n\n            this.ws.onclose = () => {\n                console.log('WebSocket disconnected');\n                this.updateConnectionStatus(false);\n\n                // T059: Auto-reconnect unless manually closed\n                if (!this.isManualClose) {\n                    this.scheduleReconnect();\n                }\n            };\n\n            this.ws.onerror = (error) => {\n                console.error('WebSocket error:', error);\n            };\n        } catch (error) {\n            console.error('Failed to create WebSocket:', error);\n            this.updateConnectionStatus(false);\n            this.scheduleReconnect();\n        }\n    }\n\n    /**\n     * T059: Schedule reconnection with exponential backoff\n     */\n    scheduleReconnect() {\n        // Show reconnecting status\n        if (this.statusEl) {\n            this.statusEl.textContent = '● Reconnecting...';\n            this.statusEl.className = 'status reconnecting';\n        }\n\n        this.reconnectTimer = setTimeout(() => {\n            console.log(`Reconnecting in ${this.reconnectDelay}ms...`);\n            this.connect();\n\n            // Exponential backoff\n            this.reconnectDelay = Math.min(\n                this.reconnectDelay * 2,\n                this.maxReconnectDelay\n            );\n        }, this.reconnectDelay);\n    }\n\n    /**\n     * Handle incoming WebSocket message\n     */\n    handleUpdate(message) {\n        if (message.type !== 'mempool_update') {\n            console.warn('Unknown message type:', message.type);\n            return;\n        }\n\n        const data = message.data;\n\n        // T057: Update price display\n        if (data.price !== undefined && data.confidence !== undefined) {\n            this.updatePrice(data.price, data.confidence);\n        }\n\n        // Update stats panel\n        if (data.stats) {\n            this.updateStats(data.stats);\n        }\n    }\n\n    /**\n     * T057: Update price display with confidence-based coloring\n     */\n    updatePrice(price, confidence) {\n        if (!this.priceEl || !this.confidenceEl) return;\n\n        // Format price with thousands separator\n        const formattedPrice = `$${Math.round(price).toLocaleString('en-US')}`;\n        this.priceEl.textContent = formattedPrice;\n\n        // Update confidence display\n        let confidenceLevel = 'Low';\n        let confidenceClass = 'low';\n\n        if (confidence > 0.8) {\n            confidenceLevel = 'High';\n            confidenceClass = 'high';\n        } else if (confidence > 0.5) {\n            confidenceLevel = 'Medium';\n            confidenceClass = 'medium';\n        }\n\n        this.confidenceEl.textContent = `Confidence: ${confidence.toFixed(2)} (${confidenceLevel})`;\n        this.confidenceEl.className = `confidence ${confidenceClass}`;\n\n        // Color price by confidence\n        this.priceEl.className = `price ${confidenceClass}`;\n    }\n\n    /**\n     * T058: Update connection status indicator\n     */\n    updateConnectionStatus(connected) {\n        if (!this.statusEl) return;\n\n        if (connected) {\n            this.statusEl.textContent = '● Connected';\n            this.statusEl.className = 'status connected';\n        } else {\n            this.statusEl.textContent = '● Disconnected';\n            this.statusEl.className = 'status disconnected';\n        }\n    }\n\n    /**\n     * Update statistics panel\n     */\n    updateStats(stats) {\n        if (!this.statsEl) return;\n\n        const uptime = this.formatUptime(stats.uptime_seconds || 0);\n\n        const statsHtml = `\n            Received: <span class=\"stat-value\">${stats.total_received || 0}</span> |\n            Filtered: <span class=\"stat-value\">${stats.total_filtered || 0}</span> |\n            Active: <span class=\"stat-value\">${stats.active_in_window || 0}</span> |\n            Uptime: <span class=\"stat-value\">${uptime}</span>\n        `;\n\n        this.statsEl.innerHTML = statsHtml;\n    }\n\n    /**\n     * Format uptime seconds to \"Xh Ym Zs\"\n     */\n    formatUptime(seconds) {\n        const hours = Math.floor(seconds / 3600);\n        const minutes = Math.floor((seconds % 3600) / 60);\n        const secs = Math.floor(seconds % 60);\n\n        const parts = [];\n        if (hours > 0) parts.push(`${hours}h`);\n        if (minutes > 0) parts.push(`${minutes}m`);\n        if (secs > 0 || parts.length === 0) parts.push(`${secs}s`);\n\n        return parts.join(' ');\n    }\n\n    /**\n     * Close WebSocket connection\n     */\n    disconnect() {\n        this.isManualClose = true;\n        if (this.ws) {\n            this.ws.close();\n        }\n        if (this.reconnectTimer) {\n            clearTimeout(this.reconnectTimer);\n            this.reconnectTimer = null;\n        }\n    }\n}\n\n/**\n * Initialize visualizer on page load\n */\ndocument.addEventListener('DOMContentLoaded', () => {\n    // Determine WebSocket URL (handle localhost and deployed)\n    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n    const host = window.location.host || 'localhost:8000';\n    const wsUrl = `${protocol}//${host}/ws/mempool`;\n\n    console.log('Connecting to WebSocket:', wsUrl);\n\n    const viz = new MempoolVisualizer(wsUrl);\n\n    if (viz.init()) {\n        viz.connect();\n\n        // Cleanup on page unload\n        window.addEventListener('beforeunload', () => {\n            viz.disconnect();\n        });\n    } else {\n        console.error('Failed to initialize visualizer');\n    }\n});"
  }
}